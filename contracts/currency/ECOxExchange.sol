// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./ECO.sol";
import "../policy/Policed.sol";
import "./ECOx.sol";

/**
 * @title EcoX Exchange Contract
 * @notice Exchange for ECOx to ECO
 */
contract ECOxExchange is Policed {
    /**
     * bits of precision used in the exponentiation approximation
     */
    uint8 public constant PRECISION_BITS = 100;

    /**
     * initial supply of ECOx at deployment
     */
    uint256 public immutable initialSupply;

    /**
     * ECOx token contract
     */
    ECOx public immutable ecox;

    /**
     * ECO token contract
     */
    ECO public immutable eco;

    /**
     * constructor
     * @param policy policy address
     * @param _ECOx ECOx address
     * @param _eco ECO address
     * @param _initialSupply initial supply of ECOx
     */
    constructor(
        Policy policy,
        ECOx _ECOx,
        ECO _eco,
        uint256 _initialSupply
    ) Policed(policy) {
        ecox = _ECOx;
        eco = _eco;
        initialSupply = _initialSupply;
    }

    /**
     * Calculates the value of ECOx by multiplying value by supply
     * @param _ecoXValue the value of ECOx
     * @return ecoValue the value of ECOx multiplied by total supply
     */
    function ecoValueOf(
        uint256 _ecoXValue
    ) public view returns (uint256 ecoValue) {
        uint256 _ecoSupply = eco.totalSupply();
        ecoValue = computeValue(_ecoXValue, _ecoSupply);
        return ecoValue;
    }

    /**
     * Calculates the value of ECOx at the total supply snapshot
     * @param _ecoXValue the value of ECOx
     * @return ecoValue the value of ECOx multiplied by the total supply at the time of snapshot
     */
    function valueAt(
        uint256 _ecoXValue
    ) public view returns (uint256 ecoValue) {
        uint256 _ecoSupplyAt = eco.totalSupplySnapshot();
        ecoValue = computeValue(_ecoXValue, _ecoSupplyAt);
        return ecoValue;
    }

    /**
     * Exchange ECOx for ECO by burning ECOx and minting ECO
     * @param _ecoXValue the value of ECOx tokens to burn
     * the output amount will always be at or greater than the expected amount by the caller, relative to the total ECO supply, as ECOx is never minted
     * unless the user miscalculates the output value, there is no need to check that output value is at least what's expected
     */
    function exchange(uint256 _ecoXValue) external {
        uint256 ecoAmount = ecoValueOf(_ecoXValue);
        ecox.burn(msg.sender, _ecoXValue);
        eco.mint(msg.sender, ecoAmount);
    }

    /**
     * Computes the value of ECO from the ECOx value and the ECO supply
     * @param _ecoXValue the value of ECOx
     * @param _ecoSupply the supply of ECO
     * @return ecoValue the value of ECO
     */
    function computeValue(
        uint256 _ecoXValue,
        uint256 _ecoSupply
    ) internal view returns (uint256 ecoValue) {
        uint256 _preciseRatio = safeLeftShift(_ecoXValue, PRECISION_BITS) /
            initialSupply;

        ecoValue =
            (generalExp(_preciseRatio, PRECISION_BITS) * _ecoSupply) >>
            PRECISION_BITS;
        return ecoValue;
    }

    /**
     * Safe Left Shift
     * @param value the value to shift
     * @param shift the amount to shift the value by
     * @return shiftedAmount the shifted amount
     */
    function safeLeftShift(
        uint256 value,
        uint8 shift
    ) internal pure returns (uint256 shiftedAmount) {
        shiftedAmount = value << shift;
        require(
            shiftedAmount >> shift == value,
            "value too large, shift out of bounds"
        );
        return shiftedAmount;
    }

    /**
     * this function can be auto-generated by the script [PrintFunctionGeneralExp.py](https://github.com/barakman/solidity-math-utils/blob/master/project/emulation/AutoGenerate/PrintFunctionGeneralExp.py).
     *
     * it approximates `e ^ x` via maclaurin summation: `(x^0)/0! + (x^1)/1! + ... + (x^n)/n!`.
     *
     * it returns `e ^ (x / 2 ^ precision) * 2 ^ precision`, that is, the result is upshifted for accuracy.
     *
     * @param _x input value
     * @param _precision precision
     * @return result `e ^ (x / 2 ^ precision) * 2 ^ precision`, that is, the result is upshifted for accuracy.
     */
    function generalExp(
        uint256 _x,
        uint8 _precision
    ) internal pure returns (uint256 result) {
        uint256 xi = _x;
        uint256 res = 0;

        xi = (xi * _x) >> _precision;
        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)
        xi = (xi * _x) >> _precision;
        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)

        result = res / 0x688589cc0e9505e2f2fee5580000000 + _x; // divide by 33! and then add x^1 / 1! (the x^0 term omitted because we subtract 1 right after)
        return result;
    }
}
